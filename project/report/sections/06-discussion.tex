\section{Discussion}
\label{sec:discussion}

\subsection{Limitations}

Due to eBPF's safety constraints, conventional maps must be constrained to some fixed size, determined at map creation time (according to the arguments of the \texttt{bpf(2)} system call used to create the map). Since \bpfcontain{} uses eBPF maps to store per-container policy, this means that, in practice, the maximum map size bounds the number of possible rules for each policy category. This upper bound is not strictly an issue since \bpfcontain{}'s current design relies on loading policy when the daemon first starts, and thus map sizes can be predetermined based on policy files' contents. However, it would be desirable to add dynamically loadable policy into future versions of \bpfcontain{}, which would require some means of handling this map size restriction at runtime.

\bpfcontain{}'s policy maps would either need to be very large or be dynamically resizable at runtime in order for dynamically loadable policy to be feasible. The former option would increase \bpfcontain{}'s memory overhead on the running system. While eBPF maps do support runtime allocation within a fixed size upper bound using the \texttt{BPF\_NO\_PREALLOC} flag, this runtime allocation comes at the cost of potential deadlocks when instrumenting critical sections in the kernel \cite{starovoitov2016_prealloc}. Its use is generally discouraged for this reason. Linux 5.10 and 5.11 introduce some new garbage collected map types \cite{singh2020_task_local_storage, singh2020_inode_local_storage}, which could alleviate this problem in practice. Integration with these new maps is discussed as topics for future work in \Cref{sub:future_work}.

Another limitation of the current research prototype is that it purely focuses on least-privilege and composability, ignoring the critical goal of virtualization that is so central to the concept of containers. As explained in \Cref{subsection:containers} and \Cref{sub:secure_containers}, the initial \bpfcontain{} prototype' goal was to provide a least-privilege-first approach to containers; thus, virtualization support is left as a topic for future work. The path forward for virtualization support in \bpfcontain{} could proceed in two disparate (yet not mutually exclusive) directions: (1) the introduction of application-transparent virtualization eBPF helpers in the kernel; and (2) the direct integration of \bpfcontain{} with existing container management implementations. \Cref{sub:future_work} covers both options in detail.

\subsection{Future Work}
\label{sub:future_work}

Linux 5.10 and Linux 5.11 introduced \texttt{inode\_local\_storage} \cite{singh2020_inode_local_storage} and \texttt{task\_local\_storage} \cite{singh2020_task_local_storage} eBPF map types, respectively. These new map types add garbage collection functionality tied down to the lifecycle of the underlying tasks and inodes to which they are bound. This garbage collection functionality allows for the implementation of security blobs, similar to those used by more conventional LSMs. Future iterations of \bpfcontain{} will incorporate these new map types, which should allow for significant implication of state and policy management, and pave the way for dynamically loadable \bpfcontain{} policy.

While \bpfcontain{} currently only implements least-privilege for containers, there is potential to add full support for virtualization through new eBPF helpers in the kernel. These helpers could, for instance, be used to transparently move process groups into new namespaces and cgroups or manage filesystem mounts within a mount namespace, transparently to the target application. \bpfcontain{} could integrate these helpers into its container lifecycle management probes to enforce namespace, cgroup, and mount policy automatically and transparently to the target application. Not only would this extension enable fully application-transparent namespace and cgroup management, but it would also obviate the need for the root privileges required to use some generic kernel virtualization techniques.

On the policy language side, the integration of virtualization with \bpfcontain{}'s enforcement mechanism presents opportunities for streamlining the configuration and policy associated with \bpfcontain{} containers. For instance, filesystem and mount namespace rules could be combined into one explicit \texttt{mount} rule. Under a given mount rule, \bpfcontain{} would mount an overlay filesystem in the container's mount namespace and automatically allow access to this mounted filesystem in its LSM policy. This new integration would not only significantly streamline container configuration, but it would also obviate the need for complex filesystem and file rules. For example, one mount rule could replace a series of file rules specifying access to required shared libraries.

An alternative route for adding virtualization support to \bpfcontain{} would be integration with existing container management frameworks such as Docker \cite{docker}, Kubernetes \cite{kubernetes}, and OpenShift \cite{openshift}. In principle, such integration could extend to any other container management framework, so long as it is compliant with the OCI (Open Container Initiative) standards \cite{oci}. This integration would have similar benefits to the eBPF helpers approach outlined above. Policy generation and enforcement could be tied directly with container configuration, offering a streamlined and more secure policy.

To harden the kernel against the privilege escalation attacks described by Xin \etal~\cite{xin2018_container_security}, \bpfcontain{} leverages a kprobe eBPF program to instrument the kernel's \texttt{commit\_creds} function. Future versions of \bpfcontain{} could apply this same technique to other security-critical code paths in the kernel to protect against \textit{other} kernel-level exploits mounted from containers. Similar techniques (using uprobes instead of kprobes) would also work on security-critical userspace applications that might be invoked within containers. Future work will involve identifying critical code paths in the kernel and the userspace TCB (trusted computing base) and building \bpfcontain{} kprobes and uprobes to harden them against exploitation.
